<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#include&lt;conio.h&gt;#include&lt;windows.h&gt;#define LENGTH 15&#x2F;&#x2F;设置围墙的长度#define WIDTH 15&#x2F;&#x2F;设置 的宽度#define OVERLAP 5 &#x2F;&#x2F;食物与蛇身重叠次数，在放置">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2021/05/14/#includestdio.h/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#include&lt;conio.h&gt;#include&lt;windows.h&gt;#define LENGTH 15&#x2F;&#x2F;设置围墙的长度#define WIDTH 15&#x2F;&#x2F;设置 的宽度#define OVERLAP 5 &#x2F;&#x2F;食物与蛇身重叠次数，在放置">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-05-14T10:44:23.461Z">
<meta property="article:modified_time" content="2021-05-14T10:44:23.766Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-#includestdio.h" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/14/#includestdio.h/" class="article-date">
  <time class="dt-published" datetime="2021-05-14T10:44:23.461Z" itemprop="datePublished">2021-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#include&lt;time.h&gt;<br>#include&lt;conio.h&gt;<br>#include&lt;windows.h&gt;<br>#define LENGTH 15//设置围墙的长度<br>#define WIDTH 15//设置 的宽度<br>#define OVERLAP 5 //食物与蛇身重叠次数，在放置食物的时候需要用到 </p>
<p>typedef struct snake { //定义一个蛇身结构体 ，该结构体为双向链表<br>    int x;//蛇身的横坐标<br>    int y;//蛇身的纵坐标<br>    struct snake* pre;//结构体指针，指向该蛇身的前面一节蛇身<br>    struct snake* next;//结构体指针，指向该蛇身的后面一节蛇身<br>}snake;<br>typedef struct foood {//定义一个食物结构体<br>    int x;//食物的横坐标<br>    int y;//食物的纵坐标<br>    char c;//食物的样子<br>}food;<br>//函数部分：将实现贪吃蛇的功能划分为多个模块；每个模块的形式为一个函数，每个函数实现自己的功能。最后，将全部函数整合起来，通过程序结构流程图实现贪吃蛇<br>void initsnake(snake* s);//初始化蛇<br>int issnakeeatitself(snake* head);//当蛇头吃到蛇尾，该游戏结束<br>int issnakeeatfood(snake* head, food* food);//判断蛇是否吃到食物<br>snake* snakegrow(snake* head);//使蛇身的长度增加一节<br>void creatfood(food* food);//随机生成一个食物<br>int avoidoverlap(snake* head, food* food);//避免蛇身的坐标和食物的坐标重合，若重合，则重新生成一个食物<br>void setfoodlocation(food* food, snake* head, int numoverlap, char c);//如果生成食物和蛇身重叠次数超过阈值，则直接按照蛇的移动方向设置食物位置<br>char setcurkeybutton(char c1);//设置当前的按键<br>void snakemove(snake* head, snake* rear, char c);//处理蛇的移动<br>void drawpicture(snake* head, food* food);//绘制蛇身，蛇头，食物和围墙的样子//1,2,33行为预处理功能中的条件编译，目的是防止头文件的重复包含和编译<br>//利用结构体指针初始化蛇信息<br>void initsnake(snake* s) {<br>    s-&gt;x = 1;<br>    s-&gt;y = 1;<br>    s-&gt;pre = NULL;<br>    s-&gt;next = NULL;<br>}//由于刚开始只有蛇头，初始化蛇头的坐标为（1，1），蛇头无前一节和后一节蛇，因此定义蛇身的前一节和后一节指针初始化为空<br>//判断游戏结束：当蛇头吃的蛇身，游戏结束了<br>int issnakeeatitself(snake* head) {<br>    int gameover = 0;<br>    snake* pt = head-&gt;next;<br>    while (pt)<br>    {<br>        if (pt-&gt;x == head-&gt;x &amp;&amp; pt-&gt;y == head-&gt;y) {<br>            gameover = 1;<br>            break;<br>        }<br>        pt = pt-&gt;next;<br>    }<br>    return gameover;<br>}//44行创建新结构体指针pt指向蛇头的下一节蛇身，45-52为单链表的遍历操作，相当于检查每一节身，如果某一节蛇身的坐标与蛇头坐标相同，判断结束，游戏也相应结束<br>//判断蛇是否吃到食物<br>int issnakeeatfood(snake* head, food* food)//形参snake<em>head，food</em>food分别为结构体蛇身指针，结构体食物指针<br>{<br>    int eat;<br>    if (head-&gt;x == food-&gt;x &amp;&amp; head-&gt;y == food-&gt;y)<br>        eat = 1;<br>    else<br>        eat = 0;<br>    return eat;<br>}//如果蛇身的坐标与食物的坐标相同，那么蛇吃到食物或者食物与蛇身重叠<br>//使蛇身的长度增加一节<br>snake <em>snakegrow(snake</em> head) {<br>    snake  <em>p = (snake</em>)malloc(sizeof(snake));<br>    snake  <em>pt = head;<br>    while (pt-&gt;next)<br>        pt = pt-&gt;next;<br>    p-&gt;pre = pt;<br>    pt-&gt;next = p;<br>    p-&gt;next = NULL;<br>    return  p;<br>}//67行定义一个新的蛇身结构体p，使用malloc函数给p分配snake类型大小的动态地址；69,70行通过循环找到蛇尾；71-73行让新的蛇身结构体p作为蛇的新蛇尾，并建立与原来蛇尾的关系；最后返回新的蛇尾结构体指针<br>//随机生成食物<br>void creatfood(food</em> food) {<br>    food-&gt;x = rand()%LENGTH;<br>    food-&gt;y = rand() % WIDTH;<br>    food-&gt;c = 65 + rand() % 26;<br>}//78，79行随机生成食物的横坐标和纵坐标；80行随机生成字符来表示食物，这里用大写字符表示<br>//避免食物坐标与蛇身坐标重合，若重合，则重新生成一个食物<br>int avoidoverlap(snake* head, food* food) {<br>    int t = 0, flag = 0;<br>    while (flag) {<br>        if (t &gt; OVERLAP)<br>            break;<br>        t++;<br>        flag = 1;<br>        snake* pt = head;<br>        while (pt) {<br>            if (pt-&gt;x == food-&gt;x &amp;&amp; pt-&gt;y == food-&gt;y) {<br>                flag = 0;<br>                creatfood(food);<br>                break;<br>            }<br>            pt = pt-&gt;next;<br>        }<br>    }<br>        return t;<br>    }//当蛇变得越来越长时，蛇身坐标和食物坐标重叠的概率会越来越高，84行设置循环检测标识和检测重叠次数，85-98行为一个循环检测行为。<br>//86行如果检测重叠t次数超过检测阈值，则结束循环重叠检测，100行返回t。91-98行利用新的蛇身结构体pt指向的蛇身的坐标和生成的食物坐标比较是否相同<br>//如果相同表示食物与蛇身重叠，则生成新的食物，再次设置检测标志为0，继续进行下一次的蛇身与食物的重叠检测<br>//如果食物和蛇身重叠检测次数超过检测阈值，则根据蛇的移动方向设置食物坐标<br>void setfoodlocation(snake* head, food* food, int numoverlap, char c) {<br>    if (numoverlap &gt; OVERLAP) {<br>        switch (c) {<br>        case ‘d’:<br>            food-&gt;x = head-&gt;x + 1;<br>            food-&gt;y = head-&gt;y;<br>            if (food-&gt;x &gt;= LENGTH)<br>                food-&gt;x -= LENGTH;<br>        case ‘a’:<br>            food-&gt;x = head-&gt;x - 1;<br>            food-&gt;y = head-&gt;y;<br>            if (food-&gt;x &gt;= LENGTH)<br>                food-&gt;x -= LENGTH;<br>        case ‘w’:<br>            food-&gt;x = head-&gt;x ;<br>            food-&gt;y = head-&gt;y-1;<br>            if (food-&gt;y &gt;=WIDTH )<br>                food-&gt;y-= WIDTH;</p>
<pre><code>    case &#39;s&#39;:
        food-&gt;x = head-&gt;x;
        food-&gt;y = head-&gt;y+1;
        if (food-&gt;y &gt;= WIDTH)
            food-&gt;y -= WIDTH;
    &#125;
&#125;
</code></pre>
<p>}//当食物和蛇身重叠检测次数超过检测阈值，为了使游戏快速进行，则将食物坐标位置直接位于蛇头的前面，从而避免两者坐标的重叠，这里使用switch语句来写程序。<br>//如果超过检测阈值，根据玩家的操作，判断蛇的移动方向。这里用向右‘d’来说明，109-110行将食物坐标位于蛇头前面一个位置，111-112行处理食物位置超过边界的问题。<br>//其他几个按键’a’，‘w’，’s’的原理与‘d’相似。<br>//设置当前的按键，确定蛇的移动方向<br>char setcurkeybutton(char c) {<br>    char c1 = _getch();<br>    if (c1 == 27)<br>        return ‘x’;<br>    if (c != ‘d’ &amp;&amp; c == ‘a’)<br>        return c = c1;<br>    else if (c != ‘a’ &amp;&amp; c == ‘d’)<br>        return c = c1;<br>    else if (c != ‘w’ &amp;&amp; c== ‘s’)<br>        return c = c1;<br>    else if (c != ‘s’ &amp;&amp; c== ‘w’)<br>        c = c1;<br>    return c;<br>}//设置当前的按键，以便确定蛇的移动方向<br>//处理蛇的移动<br>void snakemove(snake* head, snake* rear, char c) {<br>    snake* pt = rear;<br>    while (pt != head) {<br>        pt-&gt;x = pt-&gt;pre-&gt;x;<br>        pt-&gt;y = pt-&gt;pre-&gt;y;<br>        pt = pt-&gt;pre;<br>    }<br>    if (c == ‘s’) {<br>        head-&gt;y += 1;<br>        if (head-&gt;y &gt;= WIDTH)<br>            head-&gt;y -= WIDTH;<br>    }<br>    else if (c == ‘w’) {<br>        head-&gt;y -= 1;<br>        if (head-&gt;y &gt;= WIDTH)<br>            head-&gt;y -= WIDTH;<br>    }<br>    else if (c == ‘a’) {<br>        head-&gt;x -= 1;<br>        if (head-&gt;x &gt;= LENGTH)<br>            head-&gt;x -= LENGTH;<br>    }<br>    else if (c == ‘d’) {<br>        head-&gt;x += 1;<br>        if (head-&gt;x &gt;= LENGTH)<br>            head-&gt;x -= LENGTH;<br>    }<br>}//从蛇尾向蛇头前进，只要Pt不指向蛇头，将当前蛇身的前一节蛇身的坐标 给予当前蛇身，那么当前蛇身就向蛇头移动了一节蛇身的位置，155行当玩家按键为s时蛇头的纵坐标-1<br>//157 行蛇头的纵坐标超过围墙宽度，则需要重新计算 蛇头的纵坐标<br> //其他按键w，a，d的原理相同<br>//绘制蛇，食物和围墙的样子<br>void drawpicture(snake* head, food* food) {<br>    int flag;<br>    snake *pt;<br>    system(“cls”);<br>    printf(“—————\n”);//绘制上围墙<br>    for (int j = 0; j &lt; WIDTH; j++) {<br>        printf(“#”);//绘制左围墙<br>        for (int i = 0; i &lt; LENGTH; i++) {<br>            flag=0;<br>            pt=head;<br>            while (pt) {//绘制蛇<br>                if (i == pt-&gt;x &amp;&amp; j == pt-&gt;y) {<br>                    if (pt == head)<br>                printf(“@”);//绘制蛇头<br>                    else printf(“0”);//绘制蛇身<br>                    flag = 1;<br>                    break;<br>                }<br>                pt = pt-&gt;next;<br>            }<br>            if (flag ==0) {//绘制食物<br>                if (i == food-&gt;x &amp;&amp; j == food-&gt;y) {<br>                    putchar(food-&gt;c);<br>                    //putchar(food-&gt;c);<br>                    continue;<br>                }<br>                printf(“ “);//绘制右围墙<br>            }<br>        }<br>        printf(“#”);<br>        putchar(‘\n’);<br>    }<br>    printf(“—————“);//绘制下围墙<br>}<br>int main()<br>{<br>    int testnum = 0,sum=0;//食物和蛇身重叠检测次数<br>    char c = ‘d’;//方向键初始化为d，蛇向右移动<br>    srand((unsigned)time(NULL));//随机种子<br>    food food = { 5,8,’A’ };//初始化食物<br>    snake snake, * head, * rear;//定义结构体和结构体指针<br>    initsnake(&amp;snake);//初始化蛇身<br>    head = rear = &snake;//初始化 蛇只有蛇头<br>    while (1) {//游戏循环，直到游戏结束条件成立<br>        drawpicture(head, &amp;food);//绘制地图，蛇，食物，围墙<br>        printf(“\n”);<br>        printf(“窦一瑞大笨猪的最终得分为：%d”,sum);//游戏得分<br>        if (issnakeeatfood(head, &amp;food)) {//蛇吃到食物后<br>            sum+=10;//游戏得分增加10<br>            rear = snakegrow(head);//蛇身增加一节<br>            creatfood(&amp;food);//随机生成食物<br>            testnum = avoidoverlap(head, &amp;food);//避免食物和蛇身坐标重叠，重新生成食物<br>            setfoodlocation(head,&amp;food, testnum, c);//食物和蛇身重叠检测次数超过检测阈值，则根据蛇移动方向设置食物坐标 </p>
<pre><code>    &#125;
    // 按键处理 
    if (_kbhit())c = setcurkeybutton(c); //设置当前按键 
    if (c == &#39;x&#39;) break;
    snakemove(head, rear, c);//蛇朝着蛇头方向移动 
    if (issnakeeatitself(head)) &#123;//判断游戏结束，当蛇头碰到蛇身 
        puts(&quot;game over!\n&quot;);
        break;
    &#125;
    Sleep(150);//屏幕刷新时间间隔 
&#125;
_getch();
</code></pre>
<p>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/14/#includestdio.h/" data-id="ckoo73kjc00004ovk2qwr5atk" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/04/12/%E6%9C%AA%E5%91%BD%E5%90%8D/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/14/#includestdio.h/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/04/12/%E6%9C%AA%E5%91%BD%E5%90%8D/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/04/02/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>